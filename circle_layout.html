<html>

<head>
<title>myndala</title>

<!--
TODO:
SOON...
* point generator scheme...
* TESTING???
*		-is underway at least
* zoom in/out
* globals into a scope (named editor maybe?)
* better defaults mgmt/surfacing?
* split out layer types (eventually)
* do proper accessors on stuff
* separate data func. from interface (working on it)
	-what's left here?
* ID EVERYTHING! (working on it)
* styles to dedicated css

* Mandala
* from json should probably construct instances?
* render order iterator?
* Layer class?
* REALLY need hidden UUID for layer keys instead of relying on name
* mirror mode?

CURRENT LAYER(S?) EDITING
* dismissable editor
* dedicated layer edit component
* the stroke/color thing is getting confusing, sort out

LAYER UI STUFF
* icons would be nice
* expandable layer menu?
* layer visibility (control alpha probably)
* ensure correct sync between render order - layer list order
* move layer up/down
* configurable layer names
	-will users even care about layer names?
	-is there some other way to 'name' layers?

COLORS
* fill colors
* all around better color handling
* color picker?
	- better placement, feedback?

MODAL NEEDS
* dismissal callback?

LESS SOON...
* undo?
* svg features support
	- lines
	- layers
* window resize handling (is ok for now)

LATER...

WAY LATER...
* animation
-->

<style>
body {
    width:100%;
    height:100%;
	 margin: 0px 0px 0px 0px;
	 position: relative;
	 font-family:sans-serif;
	 background-color:hsl(0,0%,93%)
    /* background-color:blue; */
}

.menuBarClass {
	position:fixed;
	float:right;
	right:0px;
	top:0px;
	border-width:0px 0px 2px 2px;
	border-color:black;
	border-style:solid;
	border-bottom-left-radius: 3px;
	background-color:lightgray;
	padding: 2px;
}

.modal {
	width:50%;
	height:50%;
	color:white;
	background-color:rgb(0,0,0);
	position:fixed;
	left:0px;
	top:0px;
}

#colorPickId {
	background-color:black;
}

.pickColorButton {
	display:inline;
	border-radius:5px;
}

/* disable layer edit controls if no layers */
body[data-layer-count="0"] #menuBarId {
	display:none;
}
/* ------ */

</style>

<script type="application/javascript" src="libs/jquery-3.3.1.js"></script>
<script type="application/javascript" src="libs/utility.js"></script>
<script type="application/javascript" src="libs/fnc2d.js"></script>
<script type="application/javascript" src="libs/my2d.js"></script>
<script type="application/javascript" src="libs/myRangeInput.js"></script>
<script type="application/javascript" src="libs/WatchedValue.js"></script>
<script type="application/javascript" src="libs/modalize.js"></script>
<script type="application/javascript" src="libs/popupper.js"></script>
<script type="application/javascript" src="libs/LogChannels.js"></script>
<script type="application/javascript" src="libs/MiniTester.js"></script>
<script type="application/javascript" src="svgee.js"></script>
<script type="application/javascript" src="fncColorPicker.js"></script>

<script type="application/javascript" src="MandalaLayer.js"></script>
<script type="application/javascript" src="Mandala.js"></script>
<script type="application/javascript" src="Mandala_tests.js"></script>
<script type="application/javascript" src="MandalaSVGRenderer.js"></script>
<script type="application/javascript" src="Action.js"></script>

<!-- DATA -->
<!-- <script type="application/javascript" src="layers.js"></script> -->

 <!-- UI -->
 <link rel="stylesheet" type="text/css" href="ui/LayerMenu.css">
 <script type="application/javascript" src="ui/LayerMenu.js"></script>

<script type="application/javascript" src="ui/save_dialog.js"></script>

<!-- <link rel="stylesheet" type="text/css" href="ui/edit_layer_popup.css">
<script type="application/javascript" src="ui/edit_layer_popup.js"></script> -->

<script type="application/javascript">

// ----- EARLY INITS -----
LogChannels.CaptureConsoleLog();
// LogChannels.EnableChannel(popupper_channel_name, false);
LogChannels.EnableChannel(LayerMenu.log_channel, true);

var Actions = ActionInit();
LogChannels.EnableChannel(Actions.log_channel, false);

// ----- GLOBALS -----
var main_log_channel = "index";
var edit_log_channel = "edit";

var mandala = null;
var mandala_svg_renderer = null;

var current_layer_name = "";

var view_width;
var view_height;

var layer_menu = null;

const storage_key_mandala = "mandala";

// testing stuff
var mandala_integrity_check_after_queue_processing = true;

// ---- COLOR ----
// var current_color = { hue:0, saturation:100, lightness:50 };
var color_picker = null;
var color_picker_dialog = null;

// ---- SAVE ----
var save_dialog = null;

var current_color = WatchedValue.Create(	{hue:0, saturation:100, lightness:50},
		[function(value) {	console.log(edit_log_channel, "current_color = " + JSON.stringify(value));
									getCurrentLayer().stroke = getColorString(value);
									$("#strokeColorPickButtonId").css({"background-color":getColorString(value)});
									render();
									}]);

// --------------------------------------------------------
// TODO: BETTER NAME AND CODE
function syncRangeInputs()
{
	var current_layer = getCurrentLayer();

	$("#numSpokesId")[0].value = current_layer.number_of_spokes;
	$("#spokeLengthId")[0].value = current_layer.spoke_length;
	$("#spokeRotOffsetId")[0].value = current_layer.spoke_rot_offset;
	$("#circleRadiusId")[0].value = current_layer.radius;
	$("#strokeWidthId")[0].value = current_layer.stroke_width;

	$("#strokeColorPickButtonId").css("background-color",current_layer.stroke);
};

// ----------------------------------------------------------------------------
function setCurrentLayer(layer_name)
{
	var layer = mandala.getLayer(layer_name);

	$(`.layerList_Item`).attr("data-active-layer", false);

	current_layer_name = layer_name;
	console.log("setting layer to " + layer_name);

	$(`.layerList_Item[data-layer-name=${current_layer_name}]`).attr("data-active-layer", true);

	$("#strokeColorPickButtonId").css("background-color",layer.stroke);

	syncRangeInputs();
}

// ----------------------------------------------------------------------------
function getCurrentLayer()
{
	return mandala.getLayer(layer_menu.editing_layer);
}

// --------------------------------------------------------------------
// returns: string "hsl(n,n%,n%)"
function getColorString(color)
{
	return `hsl(${color.hue},${color.saturation}%,${color.lightness}%)`;
}

// --------------------------------------------------------------------
// receives: hsl:{hue:number, saturation:number, lightness:number}
function setCurrentColor(hsl)
{
	// todo: fill out hsl? 
	current_color.set(hsl);
}

// --------------------------------------------------------------------
function highlightLayer(layer_name)
{
	console.log(`highlighting layer: "${layer_name}`);

	highlighted_layer = layer_name;

	if (layer_name.length == 0)
	{
		$(`#mySVG g`).attr("opacity", "1.0");
	}
	else
	{
		$("#mySVG g").each( function(index) 
		{ 
			var cur_layer = $(this).attr("data-layer-name")
			console.log(cur_layer);

			var cur_opacity = cur_layer === highlighted_layer ? 1.0 : 0.25;

			$(this).attr("opacity", cur_opacity);
		});
	}
}

// --------------------------------------------------------------------
function handleAction_newDocument(action)
{
	console.log(main_log_channel, "handleAction_newDocument()"); 

	mandala.deleteAllLayers();
	layer_menu.sync();

	Actions.queueAction(new Actions.Action(Actions.ActionType.add_layer, []));
	Actions.queueAction(new Actions.Action(Actions.ActionType.render, []));
}

// --------------------------------------------------------------------
function handleAction_addLayer(action)
{
	console.log(main_log_channel, "handleAction_addLayer()"); 

	// model
	var new_layer = mandala.addCirclesLayer({stroke:getColorString(current_color.get())});

	// interface
	layer_menu.addLayer(new_layer.name);
	layer_menu.setEditingLayer(new_layer.name);

	// TODO: function...
	$("body").attr("data-layer-count", mandala.getLayerCount());

	render();

	return new_layer;
};

// --------------------------------------------------------------------
function handleAction_cloneLayer(action)
{
	console.log(main_log_channel, `handleAction_cloneLayer(${action.layers[0]})`); 

	var new_layer_name = mandala.cloneLayer(action.layers[0]);
	layer_menu.sync();
	layer_menu.setEditingLayer(new_layer_name);

	Actions.queueAction(new Actions.Action(Actions.ActionType.render));
}

// --------------------------------------------------------------------
function handleAction_deleteLayer(action)
{
	console.log(main_log_channel, `handleAction_deleteLayer()`);

	// model
	new_edit_layer_name = mandala.deleteLayer(action.layers[0]);

	if (new_edit_layer_name !== "")
	{
		layer_menu.setEditingLayer(new_edit_layer_name);
	}
	else
	{
		console.log(main_log_channel, "TODO: handle deletion leaving no layer to select");
	}

	// interface
	layer_menu.removeLayer(action.layers[0]);

	// TODO: function...
	$("body").attr("data-layer-count", mandala.getLayerCount());

	render();
}

// --------------------------------------------------------------------
function setLayerProperty(property_key, layers, value )
{
	console.log(main_log_channel, `setLayerProp(${layers[0]}, ${value})`);

	// model
	mandala.getLayer(layers[0])[property_key] = value;

	render();
};

// --------------------------------------------------------------------
function handleAction_setEditingLayers(action)
{
	console.log(main_log_channel, `setEditingLayers()`);
	console.log(main_log_channel, action.layers);

	syncRangeInputs();
}

// --------------------------------------------------------------------
function handleAction_highlightLayer(action)
{
	console.log(main_log_channel, `highlightLayer(${action.layers[0]})`);

	if (action.layers.length == 0)
	{
		$("g").attr("opacity", 1);
	}
	else
	{
		$("g").attr("opacity", 0.25);
		$(`g[data-layer-name=${action.layers[0]}]`).attr("opacity", 1);
	}
}

// --------------------------------------------------------------------
function handleAction_save(action)
{
	console.log(main_log_channel, `save()`);

	var mandala_json = mandala.toJSON();
	localStorage.setItem(storage_key_mandala, mandala_json);
}

// --------------------------------------------------------------------
function handleAction_restore(action)
{	
	console.log(main_log_channel, `restore()`);

	var mandala_json = localStorage.getItem(storage_key_mandala);

	if (null === mandala_json)
	{
		console.log(action_log_channel, `ERROR: no mandala object in localStorage`);
	}
	else
	{
		var mandala_obj = JSON.parse(mandala_json);
		mandala.fromJSON(mandala_obj);
		if (mandala.getLayerCount() > 0 )
		{
			layer_menu.sync();
			var layer = mandala.getLayerByIndex(0);
			layer_menu.setEditingLayer(layer.name);
		}
		$("body").attr("data-layer-count", mandala.getLayerCount());

		render();
	}
}

// --------------------------------------------------------------------
function handleAction_render(action)
{
	console.log(main_log_channel, "render()");
	render();
}

// --------------------------------------------------------------------
function handleAction_download(action)
{
	if (svg_blob_url)
	{
		window.URL.revokeObjectURL(svg_blob_url);
	}
	svg_blob_url = show_svg();

	save_dialog.start(svg_blob_url);
}

// --------------------------------------------------------------------
function queue_processing_done_callback()
{
	// console.log(main_log_channel, "queue_processing_done_callback()");

	if (mandala_integrity_check_after_queue_processing)
	{
		mandala.testIntegrity();
	}
}

// --------------------------------------------------------------------
var action_map = {};

action_map[Actions.ActionType.add_layer]					= handleAction_addLayer;
action_map[Actions.ActionType.set_layer_property]		= (action) => { setLayerProperty(action.layer_property, action.layers, action.value); }
action_map[Actions.ActionType.set_editing_layers]		= handleAction_setEditingLayers;
action_map[Actions.ActionType.delete_layer]				= handleAction_deleteLayer;
action_map[Actions.ActionType.highlight_layer]			= handleAction_highlightLayer;
action_map[Actions.ActionType.save]							= handleAction_save;
action_map[Actions.ActionType.restore]						= handleAction_restore;
action_map[Actions.ActionType.new_document]				= handleAction_newDocument;
action_map[Actions.ActionType.render]						= handleAction_render;
action_map[Actions.ActionType.clone_layer]				= handleAction_cloneLayer;
action_map[Actions.ActionType.download]					= handleAction_download;

Actions.setConfig({action_map:action_map, queue_processing_done_callback:queue_processing_done_callback});

// --------------------------------------------------------------------
// --------------------------------------------------------------------
// --------------------------------------------------------------------
$(document).ready( function()
{
	// ---- DATA INIT ----
	mandala_layer_class = MandalaLayerInit();
	mandala = new Mandala(mandala_layer_class);
	mandala_svg_renderer = new MandalaSVGRenderer.MandalaSVGRenderer(mandala, {width:view_width, height:view_width});

	 // --- DUCTWORK ---
	 // TODO: move editor elements to their own class/component
    // num circles
    let numSpokesRangeCallback = myRangeInput.createRange({id:'numSpokesId',
        containerId:'numSpokesRangeContainer',
        onInputHandler:(value) => { 
			  Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	  [layer_menu.editing_layer],
																	  {value:value, layer_property:"number_of_spokes"}));
			}, 
		  initialValue:0, //default_number_of_spokes,
		  wheelStep:1,
        min:1, max:100, step:1})

	 // spoke length
    let spokeLengthRangeCallback = myRangeInput.createRange({id:'spokeLengthId',
        containerId:'spokeLengthRangeContainer',
        onInputHandler:(value) => {
			Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	[layer_menu.editing_layer],
																	{value:value, layer_property:"spoke_length"}));
		  },
		  initialValue:0, //default_spoke_length,
		  wheelStep:1,
        min:0, max:500, step:1})

    // spoke_rot_offset
    let spokeRotOffsetRangeCallback = myRangeInput.createRange({id:'spokeRotOffsetId',
        containerId:'spokeRotOffsetRangeContainer', 
        onInputHandler:(value) => {
			Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	[layer_menu.editing_layer], 
																	{value:value, layer_property:"spoke_rot_offset"}));
		  },
		  initialValue:0, //default_spoke_rot_offset,
		  wheelStep:my2d.TWO_PI / 360,
        min:0, max:my2d.TWO_PI, step:0.01})

    // radius
    let circleRadiusRangeCallback = myRangeInput.createRange({id:'circleRadiusId',
        containerId:'circleRadiusRangeContainer',
        onInputHandler:(value) => {
			Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	[layer_menu.editing_layer], 
																	{value:value, layer_property:"radius"}));
		  },
        initialValue:0, //default_circle_radius,
		  wheelStep:1,
        min:5, max:500, step:1})

    // stroke_width
    let strokeWidthRangeCallback = myRangeInput.createRange({id:'strokeWidthId',
        containerId:'strokeWidthRangeContainer',
        onInputHandler:(value) => {
			Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	[layer_menu.editing_layer],
																	{value:value, layer_property:"stroke_width"}));
		  },
		  initialValue:0, //default_stroke_width,
		  wheelStep:1,
        min:1, max:20, step:1})
	 
	// --- UI INIT ---
	color_picker = new fncColorPicker.Create({color_picked_handler:onColorPicked, size:250, container_div_id:"colorpick", hue:current_color.hue, rot_offset:-Math.PI * 0.5});
	color_picker_dialog = new modalize.Create($("body"), color_picker.$container_div, "colorpick_cover", {left:50,top:20});
	save_dialog = new SaveDialog.Create();

	 // color the picker button with current color
	 // TODO: make function
	 $("#strokeColorPickButtonId").css("background-color", getColorString(current_color.get()));


	// --- UI INIT ---
	layer_menu = new LayerMenu(mandala, Actions);
	layer_menu.generateMenu();
	$("body").append(layer_menu.$menu_content);

	// var new_layer = handleAction_addLayer({});
	// restore?
	var mandala_json = localStorage.getItem(storage_key_mandala);
	if (null !== mandala_json)
	{
		Actions.queueAction(new Actions.Action(Actions.ActionType.restore, []));
	}
	else
	{
		$("#restoreButtonId").prop("disabled", true);
		Actions.queueAction(new Actions.Action(Actions.ActionType.add_layer, []));
	}

	syncRangeInputs();

	render();
});

// --------------------------------------------------------------------
function onBodyLoad()
{
    view_width = window.innerWidth;
    view_height = window.innerHeight;
};

/*
// --------------------------------------------------------------------
function onWheel()
{
};

// --------------------------------------------------------------------
function logStats()
{
   //  console.log( "viewbox width: " + $("#mySVG")[0].viewBox.baseVal.width );
   //  console.log( "viewbox height: " + $("#mySVG")[0].viewBox.baseVal.height );
}

// --------------------------------------------------------------------
function zoomIn()
{
    $("#mySVG")[0].viewBox.baseVal.width -= 10;
    $("#mySVG")[0].viewBox.baseVal.height -= 10;

    logStats();
}

// --------------------------------------------------------------------
function zoomOut()
{
    $("#mySVG")[0].viewBox.baseVal.width += 10;
    $("#mySVG")[0].viewBox.baseVal.height += 10;

    logStats();
}
*/

// --------------------------------------------------------------------
function show_svg() {
    var svg = document.getElementById("mySVG");
    var serializer = new XMLSerializer();
    var svg_blob = new Blob([serializer.serializeToString(svg)],
                            {'type': "image/svg+xml"});
    var object_url = URL.createObjectURL(svg_blob);

    // later... revokeObjectURL();
	 // var svg_win = window.open(url, "svg_win");
	 return object_url;
}

// --------------------------------------------------------------------
function render()
{
    $("#mySVG").remove();

   // var svg_elem = generate_svg();
	var svg_elem = mandala_svg_renderer.render();

    $("body").append(svg_elem);
}


// TODO: move upward
var svg_blob_url = null;

var svg_file_version = 1;

// ----------------------------------------------------------------------------
// save state in local storage
function onSave()
{
	console.log(main_log_channel, "onSave()");
	Actions.queueAction(new Actions.Action(Actions.ActionType.save, []));
}

// ----------------------------------------------------------------------------
function onRestore()
{
	console.log(main_log_channel, "onRestore()");
	Actions.queueAction(new Actions.Action(Actions.ActionType.restore, []));
}

// ----------------------------------------------------------------------------
function onDownload()
{
	// TODO: move to function?
	if (svg_blob_url)
	{
		window.URL.revokeObjectURL(svg_blob_url);
	}
	svg_blob_url = show_svg();

	save_dialog.start(svg_blob_url);
}

// ----------------------------------------------------------------------------
function onAddLayer()
{
	var new_layer = addLayer();
	setCurrentLayer(new_layer.name);
	syncRangeInputs();
	render();
}

// ----------------------------------------------------------------------------
function onPickStrokeColor()
{
	color_picker_dialog.start();
}

// ----------------------------------------------------------------------------
function onColorPicked(color)
{
	color_picker_dialog.dismiss();

	current_color.set(color);

	layer_menu.setEditingLayerColor(getColorString(current_color.get()));

	var background_color_css = { "background-color":getColorString(current_color.get()) };
	$("#strokeColorPickButtonId").css(background_color_css);

	render();
}

</script>

</head>

<!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  -->
<body data-layer-count="0" onload="onBodyLoad()">

<div class="menuBarClass" id="menuBarId">
	<table>
		<tr><td id="numSpokesValueId">petals</td><td id="numSpokesRangeContainer"></td></tr>
		<tr><td>length</td><td id="spokeLengthRangeContainer"></td></tr>
		<tr><td>rot</td><td id="spokeRotOffsetRangeContainer"></td></tr>
		<tr><td>radius</td><td id="circleRadiusRangeContainer"></td></tr>
		<tr><td>stroke</td><td id="strokeWidthRangeContainer"></td></tr>
	</table>
	 <button id="strokeColorPickButtonId" class="pickColorButton" onclick="onPickStrokeColor()">sss</button>
	 <button id="fillColorPickbuttonId" class="pickColorButton" onclick="onPickFillcolor()">fff</button>
</div>

<!-- <svg width="100%" height="100%" id="mySVG" viewbox="0 0 110 110"> -->
<!-- <g> -->
<!-- crosshairs -->
<!--
<line x1="-100" y1="0" x2="100" y2="0" style="stroke:rgb(0,0,0);stroke-width:2" />
<line x1="-0" y1="-100" x2="0" y2="100" style="stroke:rgb(0,0,0);stroke-width:2" />
-->
<!-- </g> -->
<!-- </svg> -->

</body>

</html>