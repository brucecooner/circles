<html>

<head>
<title>fractala</title>

<!--
TODO:
SOON...
* fill colors
* layer highlight is broken
* clear all button?
* all around better color handling
* better defaults mgmt/surfacing?
* split out layer types (eventually)
* do proper accessors on stuff
* get jquery 3.3.1
* separate data func. from interface (working on it)
* ID EVERYTHING! (working on it)
* styles to dedicated css
* color picker?
	- better placement, feedback?
* remove/delete layer
* configurable layer names
	-will users even care about layer names?
* dismissable editor
* the stroke/color thing is getting confusing, sort out

* dedicated layer edit component

LAYER UI STUFF
* expandable layer menu?
* layer visibility (control alpha probably)
* way to highlight layer?
* move layer up/down
* clone layer?
* ensure correct sync between render order - layer list order

MODAL NEEDS
* dismissal callback?

LESS SOON...
* multiple stages
	-define "stage"
	-stage renderer?
* svg features support
	- lines
	- layers
* window resize handling (is ok for now)

LATER...
*	layers?
* stage "component"
	-accordions?
	-re-arrangeable?
WAY LATER...
* animation
-->

<style>
body {
    width:100%;
    height:100%;
	 margin: 0px 0px 0px 0px;
	 position: relative;
	 font-family:sans-serif;
	 background-color:hsl(0,0%,93%)
    /* background-color:blue; */
}

.menuBarClass {
	position:fixed;
	float:right;
	right:0px;
	top:0px;
	border-width:0px 0px 2px 2px;
	border-color:black;
	border-style:solid;
	border-bottom-left-radius: 3px;
	background-color:lightgray;
	padding: 2px;
}

.menuBarClass button {
    display:block;
    border-radius: 3px;
}


.modal {
	width:50%;
	height:50%;
	color:white;
	background-color:rgb(0,0,0);
	position:fixed;
	left:0px;
	top:0px;
}

#colorPickId {
	background-color:black;
}

/* disable layer edit controls if no layers */
body[data-layer-count="0"] #menuBarId {
	display:none;
}
/* ------ */

</style>

<script type="application/javascript" src="jquery-3.1.1.min.js"></script>
<script type="application/javascript" src="libs/utility.js"></script>
<script type="application/javascript" src="libs/fnc2d.js"></script>
<script type="application/javascript" src="libs/my2d.js"></script>
<script type="application/javascript" src="libs/myRangeInput.js"></script>
<script type="application/javascript" src="libs/WatchedValue.js"></script>
<script type="application/javascript" src="libs/modalize.js"></script>
<script type="application/javascript" src="libs/popupper.js"></script>
<script type="application/javascript" src="libs/LogChannels.js"></script>
<script type="application/javascript" src="svgee.js"></script>
<script type="application/javascript" src="fncColorPicker.js"></script>

<script type="application/javascript" src="Fractala.js"></script>
<script type="application/javascript" src="FractalaSVGRenderer.js"></script>

<!-- DATA -->
<!-- <script type="application/javascript" src="layers.js"></script> -->

 <!-- UI -->
 <link rel="stylesheet" type="text/css" href="ui/LayerMenu.css">
 <script type="application/javascript" src="ui/LayerMenu.js"></script>

<script type="application/javascript" src="ui/save_dialog.js"></script>

<!-- <link rel="stylesheet" type="text/css" href="ui/edit_layer_popup.css">
<script type="application/javascript" src="ui/edit_layer_popup.js"></script> -->

<script type="application/javascript">

// ----- EARLY INITS -----
LogChannels.CaptureConsoleLog();

// LogChannels.EnableChannel(popupper_channel_name, false);
LogChannels.EnableChannel(LayerMenu.log_channel, true);

// ----- GLOBALS -----
var main_log_channel = "main";
var edit_log_channel = "edit";

var fractala = null;
var fractala_svg_renderer = null;

var current_layer_name = "";

var view_width;
var view_height;

var layer_menu = null;

var highlighted_layer = "";

// ---- COLOR ----
// var current_color = { hue:0, saturation:100, lightness:50 };
var color_picker = null;
var color_picker_dialog = null;

// ---- SAVE ----
var save_dialog = null;

var current_color = WatchedValue.Create(	{hue:0, saturation:100, lightness:50},
		[function(value) {	console.log(edit_log_channel, "current_color = " + JSON.stringify(value));
									getCurrentLayer().stroke = getColorString(value);
									$("#colorPickButtonId").css({"background-color":getColorString(value)});
									render();
									}]);

// --------------------------------------------------------
// TODO: BETTER NAME AND CODE
function syncRangeInputs()
{
	var current_layer = getCurrentLayer();

	$("#numSpokesId")[0].value = current_layer.number_of_spokes;
	$("#spokeLengthId")[0].value = current_layer.spoke_length;
	$("#spokeRotOffsetId")[0].value = current_layer.spoke_rot_offset;
	$("#circleRadiusId")[0].value = current_layer.radius;
	$("#strokeWidthId")[0].value = current_layer.stroke_width;

	$("#colorPickButtonId").css("background-color",current_layer.stroke);
};

// ----------------------------------------------------------------------------
function setCurrentLayer(layer_name)
{
	var layer = fractala.getLayer(layer_name);

	$(`.layerList_Item`).attr("data-active-layer", false);

	current_layer_name = layer_name;
	console.log("setting layer to " + layer_name);

	$(`.layerList_Item[data-layer-name=${current_layer_name}]`).attr("data-active-layer", true);

	$("#colorPickButtonId").css("background-color",layer.stroke);

	syncRangeInputs();
}

// ----------------------------------------------------------------------------
function getCurrentLayer()
{
	return fractala.getLayer(layer_menu.editing_layer);
}

// --------------------------------------------------------------------
// returns: string "hsl(n,n%,n%)"
function getColorString(color)
{
	return `hsl(${color.hue},${color.saturation}%,${color.lightness}%)`;
}

// --------------------------------------------------------------------
// receives: hsl:{hue:number, saturation:number, lightness:number}
function setCurrentColor(hsl)
{
	// todo: fill out hsl? 
	current_color.set(hsl);
}

// --------------------------------------------------------------------
function highlightLayer(layer_name)
{
	console.log(`highlighting layer: "${layer_name}`);

	highlighted_layer = layer_name;

	if (layer_name.length == 0)
	{
		$(`#mySVG g`).attr("opacity", "1.0");
	}
	else
	{
		$("#mySVG g").each( function(index) 
		{ 
			var cur_layer = $(this).attr("data-layer-name")
			console.log(cur_layer);

			var cur_opacity = cur_layer === highlighted_layer ? 1.0 : 0.25;

			$(this).attr("opacity", cur_opacity);
		});
	}
}

// --- ACTION HANDLERS ---
// TODO: own file ?

// ============================================================================
var ActionType = {
	add_layer:"add_layer" ,
	set_layer_property:"set_layer_property",
	set_editing_layers:"set_editing_layers",
	delete_layer:"delete_layer",
	highlight_layer:"highlight_layer",
};

class Action
{
	// -------------------------------------------------------------------------
	// receives:
	//		-action_type:string
	//		-layers:[string,...]
	//		-parameters:{layer_property:string, value:any}
	constructor(action_type, layers, parameters)
	{
		this.action_type = action_type;
		this.layers = layers;

		Object.assign(this, parameters);
	}
};

// -------------------------------------------------------------------------
// -------------------------------------------------------------------------
var action_log_channel = "action_handlers";

// ACTION QUEUE
// [ Action,...]
var actions_queue = [];
var processing_queue = false;
function processActionQueue()
{
	console.log(action_log_channel, "begin processing queue");
	processing_queue = true;
	while (actions_queue.length > 0)
	{
		// pull first action...
		var current_action = actions_queue[0];
		actions_queue.splice(0,1);
		dispatchAction(current_action);
	}
	processing_queue = false;
	console.log(action_log_channel, "done processing queue");
}

// --------------------------------------------------------------------
function queueAction(action)
{
	actions_queue.push(action);

	// begin, if not already processing
	if (!processing_queue)
	{
		processActionQueue();
	}
}

// --------------------------------------------------------------------
function handleAction_addLayer(action)
{
	console.log(action_log_channel, "handleAction_addLayer()"); 

	// model
	var new_layer = fractala.addCirclesLayer({stroke:getColorString(current_color.get())});

	// interface
	layer_menu.addLayer(new_layer.name);
	layer_menu.setEditingLayer(new_layer.name);

	// TODO: function...
	$("body").attr("data-layer-count", fractala.getLayerCount());

	render();

	return new_layer;
};

// --------------------------------------------------------------------
function handleAction_deleteLayer(action)
{
	console.log(action_log_channel, `handleAction_deleteLayer()`);

	// model
	new_edit_layer_name = fractala.deleteLayer(action.layers[0]);

	if (new_edit_layer_name !== "")
	{
		layer_menu.setEditingLayer(new_edit_layer_name);
	}
	else
	{
		console.log(action_log_channel, "TODO: handle deletion leaving no layer to select");
	}

	// interface
	layer_menu.removeLayer(action.layers[0]);

	// TODO: function...
	$("body").attr("data-layer-count", fractala.getLayerCount());

	render();
}

// --------------------------------------------------------------------
function setLayerProperty(property_key, layers, value )
{
	console.log(action_log_channel, `setLayerProp(${layers[0]}, ${value})`);

	// model
	fractala.getLayer(layers[0])[property_key] = value;

	render();
};

// --------------------------------------------------------------------
function handleAction_setEditingLayers(action)
{
	console.log(action_log_channel, `setEditingLayers()`);
	console.log(action_log_channel, action.layers);

	syncRangeInputs();
}

// --------------------------------------------------------------------
function handleAction_highlightLayer(action)
{
	console.log(action_log_channel, `highlightLayer(${action.layers[0]})`);

	if (action.layers.length == 0)
	{
		$("g").attr("opacity", 1);
	}
	else
	{
		$("g").attr("opacity", 0.25);
		$(`g[data-layer-name=${action.layers[0]}]`).attr("opacity", 1);
	}
}

// --------------------------------------------------------------------
var action_map = {};

action_map[ActionType.add_layer]					= handleAction_addLayer;
action_map[ActionType.set_layer_property]		= (action) => { setLayerProperty(action.layer_property, action.layers, action.value); }
action_map[ActionType.set_editing_layers]		= handleAction_setEditingLayers;
action_map[ActionType.delete_layer]				= handleAction_deleteLayer;
action_map[ActionType.highlight_layer]			= handleAction_highlightLayer;

// --------------------------------------------------------------------
function dispatchAction(action)
{
	console.log(action_log_channel, "dispatchAction()"); 
	console.log(action_log_channel, action);

	if (action_map.hasOwnProperty(action.action_type))
	{
		var action_handler = action_map[action.action_type];

		action_handler(action);
	}
	else
	{
		console.log(action_log_channel, `ERROR: action type ${action.action_type} not mapped to handler`);
	}
}

// --------------------------------------------------------------------
// --------------------------------------------------------------------
// --------------------------------------------------------------------
$(document).ready( function()
{
	// ---- DATA INIT ----
	fractala = new Fractala.Fractala();
	fractala_svg_renderer = new FractalaSVGRenderer.FractalaSVGRenderer(fractala, {width:view_width, height:view_width});

	 // --- DUCTWORK ---
	 // TODO: move editor elements to their own class/component
    // num circles
    let numSpokesRangeCallback = myRangeInput.createRange({id:'numSpokesId',
        containerId:'numSpokesRangeContainer',
        onInputHandler:(value) => { 
			  queueAction(new Action(ActionType.set_layer_property, [layer_menu.editing_layer], {value:value, layer_property:"number_of_spokes"}));
			}, 
		  initialValue:0, //default_number_of_spokes,
		  wheelStep:1,
        min:1, max:100, step:1})

	 // spoke length
    let spokeLengthRangeCallback = myRangeInput.createRange({id:'spokeLengthId',
        containerId:'spokeLengthRangeContainer',
        onInputHandler:(value) => {
			queueAction(new Action(ActionType.set_layer_property, [layer_menu.editing_layer], {value:value, layer_property:"spoke_length"}));
		  },
		  initialValue:0, //default_spoke_length,
		  wheelStep:1,
        min:0, max:500, step:1})

    // spoke_rot_offset
    let spokeRotOffsetRangeCallback = myRangeInput.createRange({id:'spokeRotOffsetId',
        containerId:'spokeRotOffsetRangeContainer', 
        onInputHandler:(value) => {
			queueAction(new Action(ActionType.set_layer_property, [layer_menu.editing_layer], {value:value, layer_property:"spoke_rot_offset"}));
		  },
		  initialValue:0, //default_spoke_rot_offset,
		  wheelStep:my2d.TWO_PI / 360,
        min:0, max:my2d.TWO_PI, step:0.01})

    // radius
    let circleRadiusRangeCallback = myRangeInput.createRange({id:'circleRadiusId',
        containerId:'circleRadiusRangeContainer',
        onInputHandler:(value) => {
			queueAction(new Action(ActionType.set_layer_property, [layer_menu.editing_layer], {value:value, layer_property:"radius"}));
		  },
        initialValue:0, //default_circle_radius,
		  wheelStep:1,
        min:5, max:500, step:1})

    // stroke_width
    let strokeWidthRangeCallback = myRangeInput.createRange({id:'strokeWidthId',
        containerId:'strokeWidthRangeContainer',
        onInputHandler:(value) => {
			queueAction(new Action(ActionType.set_layer_property, [layer_menu.editing_layer], {value:value, layer_property:"stroke_width"}));
		  },
		  initialValue:0, //default_stroke_width,
		  wheelStep:1,
        min:1, max:20, step:1})
	 
	// --- UI INIT ---
	color_picker = new fncColorPicker.Create({color_picked_handler:onColorPicked, size:250, container_div_id:"colorpick", hue:current_color.hue, rot_offset:-Math.PI * 0.5});
	color_picker_dialog = new modalize.Create($("body"), color_picker.$container_div, "colorpick_cover", {left:50,top:20});
	save_dialog = new SaveDialog.Create();

	 // color the picker button with current color
	 // TODO: make function
	 $("#colorPickButtonId").css("background-color", getColorString(current_color.get()));

	// default the model
	// var default_layer = addLayer();
	// current_layer_name = default_layer.name;
	// setCurrentLayer(default_layer.name);

	// --- UI INIT ---
	layer_menu = new LayerMenu(fractala, queueAction);
	layer_menu.generateMenu();
	$("body").append(layer_menu.$menu_content);

	var new_layer = handleAction_addLayer({});

	syncRangeInputs();

	render();
});

// --------------------------------------------------------------------
function onBodyLoad()
{
    view_width = window.innerWidth;
    view_height = window.innerHeight;
};

/*
// --------------------------------------------------------------------
function onWheel()
{
};

// --------------------------------------------------------------------
function logStats()
{
   //  console.log( "viewbox width: " + $("#mySVG")[0].viewBox.baseVal.width );
   //  console.log( "viewbox height: " + $("#mySVG")[0].viewBox.baseVal.height );
}

// --------------------------------------------------------------------
function zoomIn()
{
    $("#mySVG")[0].viewBox.baseVal.width -= 10;
    $("#mySVG")[0].viewBox.baseVal.height -= 10;

    logStats();
}

// --------------------------------------------------------------------
function zoomOut()
{
    $("#mySVG")[0].viewBox.baseVal.width += 10;
    $("#mySVG")[0].viewBox.baseVal.height += 10;

    logStats();
}
*/

// --------------------------------------------------------------------
function show_svg() {
    var svg = document.getElementById("mySVG");
    var serializer = new XMLSerializer();
    var svg_blob = new Blob([serializer.serializeToString(svg)],
                            {'type': "image/svg+xml"});
    var object_url = URL.createObjectURL(svg_blob);

    // later... revokeObjectURL();
	 // var svg_win = window.open(url, "svg_win");
	 return object_url;
}

// --------------------------------------------------------------------
function render()
{
    $("#mySVG").remove();

   // var svg_elem = generate_svg();
	var svg_elem = fractala_svg_renderer.render();

    $("body").append(svg_elem);
}


// TODO: move upward
var svg_blob_url = null;

var svg_file_version = 1;

// ----------------------------------------------------------------------------
function onSave()
{
	// TODO: move to function?
	if (svg_blob_url)
	{
		window.URL.revokeObjectURL(svg_blob_url);
	}
	svg_blob_url = show_svg();

	save_dialog.start(svg_blob_url);
}

// ----------------------------------------------------------------------------
function onAddLayer()
{
	var new_layer = addLayer();
	setCurrentLayer(new_layer.name);
	syncRangeInputs();
	render();
}

// ----------------------------------------------------------------------------
function onPickColor()
{
	color_picker_dialog.start();
}

// ----------------------------------------------------------------------------
function onColorPicked(color)
{
	color_picker_dialog.dismiss();

	current_color.set(color);

	layer_menu.setEditingLayerColor(getColorString(current_color.get()));

	var background_color_css = { "background-color":getColorString(current_color.get()) };
	$("#colorPickButtonId").css(background_color_css);

	render();
}

</script>

</head>

<!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  -->
<body data-layer-count="0" onload="onBodyLoad()">

<div class="menuBarClass" id="menuBarId">
	<table>
		<tr><td id="numSpokesValueId">num</td><td id="numSpokesRangeContainer"></td></tr>
		<tr><td>length</td><td id="spokeLengthRangeContainer"></td></tr>
		<tr><td>rot</td><td id="spokeRotOffsetRangeContainer"></td></tr>
		<tr><td>radius</td><td id="circleRadiusRangeContainer"></td></tr>
		<tr><td>stroke</td><td id="strokeWidthRangeContainer"></td></tr>
	</table>
	 <button id="colorPickButtonId" onclick="onPickColor()">xxx</button>
	 <button onclick="onSave()">save</button>
</div>


<!-- <svg width="100%" height="100%" id="mySVG" viewbox="0 0 110 110"> -->
<!-- <g> -->
<!-- crosshairs -->
<!--
<line x1="-100" y1="0" x2="100" y2="0" style="stroke:rgb(0,0,0);stroke-width:2" />
<line x1="-0" y1="-100" x2="0" y2="100" style="stroke:rgb(0,0,0);stroke-width:2" />
-->

<!--
<line x1="10" y1="10" x2="100" y2="10" style="stroke:rgb(255,0,0);stroke-width:2" />
<line x1="100" y1="10" x2="100" y2="100" style="stroke:rgb(0,255,0);stroke-width:2" />
<line x1="100" y1="100" x2="10" y2="100" style="stroke:rgb(0,0,255);stroke-width:2" />
<line x1="10" y1="100" x2="10" y2="10" style="stroke:rgb(0,255,255);stroke-width:2" />
-->

<!-- </g> -->
<!-- </svg> -->

</body>

</html>