<html>

<head>
<title>myndala</title>

<!--
TODO:
SOON...
* point generator scheme...
* TESTING???
*		-is underway at least
* zoom in/out
* globals into a scope (named editor maybe?)
* better defaults mgmt/surfacing?
* split out layer types (eventually)
* do proper accessors on stuff
* separate data func. from interface (working on it)
	-what's left here?
* ID EVERYTHING! (working on it)
* styles to dedicated css

* Mandala
* render order iterator?
* REALLY need hidden UUID for layer keys instead of relying on name
* mirror mode?

CURRENT LAYER(S?) EDITING
* dismissable editor
* dedicated layer edit component
* the stroke/color thing is getting confusing, sort out

LAYER UI STUFF
* icons would be nice
* expandable layer menu?
* layer visibility (control alpha probably)
* ensure correct sync between render order - layer list order
* move layer up/down
* configurable layer names
	-will users even care about layer names?
	-is there some other way to 'name' layers?

COLORS
* all around better color handling
	- need saturation/lightness controls
* color picker?
	- better placement, feedback?


MODAL NEEDS
* dismissal callback?

LESS SOON...
* undo?
* svg features support
	- lines
	- layers
* window resize handling (is ok for now)

LATER...

WAY LATER...
* animation
-->

<style>
body {
    width:100%;
    height:100%;
	 margin: 0px 0px 0px 0px;
	 position: relative;
	 font-family:sans-serif;
	 background-color:hsl(0,0%,93%)
    /* background-color:blue; */
}

.menuBarClass {
	position:fixed;
	float:right;
	right:0px;
	top:0px;
	border-width:0px 0px 2px 2px;
	border-color:black;
	border-style:solid;
	border-bottom-left-radius: 3px;
	background-color:lightgray;
	padding: 2px;
}

.modal {
	width:50%;
	height:50%;
	color:white;
	background-color:rgb(0,0,0);
	position:fixed;
	left:0px;
	top:0px;
}

#colorPickId {
	background-color:black;
}

.pickColorButton {
	display:inline;
	border-radius:5px;
}

/* disable layer edit controls if no layers */
body[data-layer-count="0"] #menuBarId {
	display:none;
}
/* ------ */

</style>

<script type="application/javascript" src="libs/jquery-3.3.1.js"></script>
<script type="application/javascript" src="libs/utility.js"></script>
<script type="application/javascript" src="libs/fnc2d.js"></script>
<script type="application/javascript" src="libs/my2d.js"></script>
<script type="application/javascript" src="libs/myRangeInput.js"></script>
<script type="application/javascript" src="libs/WatchedValue.js"></script>
<script type="application/javascript" src="libs/modalize.js"></script>
<script type="application/javascript" src="libs/popupper.js"></script>
<script type="application/javascript" src="libs/LogChannels.js"></script>
<script type="application/javascript" src="libs/MiniTester.js"></script>
<script type="application/javascript" src="svgee.js"></script>
<script type="application/javascript" src="fncColorPicker.js"></script>
<script type="application/javascript" src="genSinePoints.js"></script>

<script type="application/javascript" src="MandalaLayer.js"></script>
<script type="application/javascript" src="MandalaPetal.js"></script>
<script type="application/javascript" src="Mandala.js"></script>
<script type="application/javascript" src="Mandala_tests.js"></script>
<script type="application/javascript" src="MandalaSVGRenderer.js"></script>
<script type="application/javascript" src="Action.js"></script>

<!-- DATA -->
<!-- <script type="application/javascript" src="layers.js"></script> -->

 <!-- UI -->
 <link rel="stylesheet" type="text/css" href="ui/LayerMenu.css">
 <script type="application/javascript" src="ui/LayerMenu.js"></script>

<script type="application/javascript" src="ui/save_dialog.js"></script>

<!-- <link rel="stylesheet" type="text/css" href="ui/edit_layer_popup.css">
<script type="application/javascript" src="ui/edit_layer_popup.js"></script> -->

<script type="application/javascript">

// ----- EARLY INITS -----
LogChannels.CaptureConsoleLog();
// LogChannels.EnableChannel(popupper_channel_name, false);
LogChannels.EnableChannel(LayerMenu.log_channel, true);

var Actions = ActionInit();
LogChannels.EnableChannel(Actions.log_channel, false);

// ----- GLOBALS -----

var disabled_color_string = "hsl(0,0%, 50%)";
var main_log_channel = "index";
var edit_log_channel = "edit";

var mandala = null;
var mandala_svg_renderer = null;

// var current_layer_name = "";

var view_width;
var view_height;

var layer_menu = null;

const storage_key_mandala = "mandala";

// testing stuff
var mandala_integrity_check_after_queue_processing = true;

// ---- COLOR ----
var color_picker = null;
var color_picker_dialog = null;

// if not picking stroke, then picking fill
// yeah I know this is lame and will get fixed
var picking_stroke_color = true;

// ---- SAVE ----
var save_dialog = null;

var current_stroke_enabled = WatchedValue.Create(	true,
		[function(value)	{	console.log(edit_log_channel, "stroke enabled = " + value);
									var color_string = value ? getColorString(current_stroke_color.get()) : "none";
									Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																							[layer_menu.editing_layer],
																							{value:color_string, layer_property:"stroke"}));
									syncLayerEditStrokeControls(value, getColorString(current_stroke_color.get()));
									render();
									}]);

var current_fill_enabled = WatchedValue.Create(	false,
		[function(value)	{	console.log(edit_log_channel, "fill enabled = " + value);
									var color_string = value ? getColorString(current_fill_color.get()) : "none";
									Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																								[layer_menu.editing_layer],
																								{value:color_string, layer_property:"fill"}));
									syncLayerEditFillControls(value, getColorString(current_fill_color.get()));
									render();
									}]);


var current_stroke_color = WatchedValue.Create(	{hue:0, saturation:100, lightness:50},
		[function(value) {	console.log(edit_log_channel, "current_stroke_color = " + JSON.stringify(value));
									getCurrentLayer().stroke = getColorString(value);
									layer_menu.setEditingLayerColor(getColorString(current_stroke_color.get()));
									$("#strokeColorPickButtonId").css({"background-color":getColorString(value)});
									render();
									}]);

var current_fill_color = WatchedValue.Create(	{hue:100, saturation:100, lightness:50},
		[function(value) {	console.log(edit_log_channel, "current_fill_color = " + JSON.stringify(value));
									getCurrentLayer().fill = getColorString(value);
									$("#fillColorPickButtonId").css({"background-color":getColorString(value)});
									render();
									}]);

// ----------------------------------------------------------------------------
function syncLayerEditStrokeControls(stroke_enabled, stroke_color_string)
{
	$("#strokeEnabledChkId").prop("checked", stroke_enabled);
	$("#strokeColorPickButtonId").prop("disabled", !stroke_enabled);
	$("#strokeColorPickButtonId").css({"background-color":stroke_enabled ? stroke_color_string : disabled_color_string});
};

// ----------------------------------------------------------------------------
function syncLayerEditFillControls(fill_enabled, fill_color_string)
{
	$("#fillEnabledChkId").prop("checked", fill_enabled);
	$("#fillColorPickButtonId").prop("disabled", !fill_enabled);
	$("#fillColorPickButtonId").css({"background-color":fill_enabled ? fill_color_string : disabled_color_string });
};

// --------------------------------------------------------
function syncLayerEditInputs()
{
	var current_layer = getCurrentLayer();

	$("#numSpokesId")[0].value = current_layer.number_of_spokes;
	$("#spokeLengthId")[0].value = current_layer.spoke_length;
	$("#spokeRotOffsetId")[0].value = current_layer.spoke_rot_offset;
	$("#circleRadiusId")[0].value = current_layer.radius;
	$("#strokeWidthId")[0].value = current_layer.stroke_width;
	$("#numPointsId")[0].value = current_layer.number_of_points;
	$("#spokeEndRotId")[0].value = current_layer.spoke_end_rot;

	syncLayerEditStrokeControls(current_layer.strokeOn, current_layer.stroke);
	syncLayerEditFillControls(current_layer.fillOn, current_layer.fill);
};

// ----------------------------------------------------------------------------
// TODO: this should be in the layers menu
function setCurrentLayer(layer_name)
{
	var layer = mandala.getLayer(layer_name);

	$(`.layerList_Item`).attr("data-active-layer", false);

	// current_layer_name = layer_name;
	console.log("setting layer to " + layer_name);

	$(`.layerList_Item[data-layer-name=${layer_name}]`).attr("data-active-layer", true);

	syncLayerEditInputs();
}

// ----------------------------------------------------------------------------
function getCurrentLayer()
{
	return mandala.getLayer(layer_menu.editing_layer);
}

// --------------------------------------------------------------------
// returns: string "hsl(n,n%,n%)"
function getColorString(color)
{
	return `hsl(${color.hue},${color.saturation}%,${color.lightness}%)`;
}

// --------------------------------------------------------------------
// receives: hsl:{hue:number, saturation:number, lightness:number}
function setCurrentColor(hsl)
{
	// todo: fill out hsl? 
	current_stroke_color.set(hsl);
}

// --------------------------------------------------------------------
function highlightLayer(layer_name)
{
	console.log(`highlighting layer: "${layer_name}`);

	highlighted_layer = layer_name;

	if (layer_name.length == 0)
	{
		$(`#mySVG g`).attr("opacity", "1.0");
	}
	else
	{
		$("#mySVG g").each( function(index) 
		{ 
			var cur_layer = $(this).attr("data-layer-name")
			console.log(cur_layer);

			var cur_opacity = cur_layer === highlighted_layer ? 1.0 : 0.25;

			$(this).attr("opacity", cur_opacity);
		});
	}
}

// --------------------------------------------------------------------
function handleAction_newDocument(action)
{
	console.log(main_log_channel, "handleAction_newDocument()"); 

	mandala.deleteAllLayers();
	layer_menu.sync();

	Actions.queueAction(new Actions.Action(Actions.ActionType.add_layer, []));
	Actions.queueAction(new Actions.Action(Actions.ActionType.render, []));
}

// --------------------------------------------------------------------
function handleAction_addLayer(action)
{
	console.log(main_log_channel, "handleAction_addLayer()"); 

	// model
	// TODO: FUNCTIONALIZE THIS
	var stroke_color_string = current_stroke_enabled.get() ? getColorString(current_stroke_color.get()) : "none";
	var fill_color_string = current_fill_enabled.get() ? getColorString(current_fill_color.get()) : "none";
	var new_layer = mandala.addCirclesLayer({stroke:stroke_color_string, fill:fill_color_string});

	// interface
	layer_menu.addLayer(new_layer.name);
	layer_menu.setEditingLayer(new_layer.name);

	// TODO: function...
	$("body").attr("data-layer-count", mandala.getLayerCount());

	render();

	return new_layer;
};

// --------------------------------------------------------------------
function handleAction_cloneLayer(action)
{
	console.log(main_log_channel, `handleAction_cloneLayer(${action.layers[0]})`); 

	var new_layer_name = mandala.cloneLayer(action.layers[0]);
	layer_menu.sync();
	layer_menu.setEditingLayer(new_layer_name);

	Actions.queueAction(new Actions.Action(Actions.ActionType.render));
}

// --------------------------------------------------------------------
function handleAction_deleteLayer(action)
{
	console.log(main_log_channel, `handleAction_deleteLayer()`);

	// model
	new_edit_layer_name = mandala.deleteLayer(action.layers[0]);

	if (new_edit_layer_name !== "")
	{
		layer_menu.setEditingLayer(new_edit_layer_name);
	}
	else
	{
		console.log(main_log_channel, "TODO: handle deletion leaving no layer to select");
	}

	// interface
	layer_menu.removeLayer(action.layers[0]);

	// TODO: function...
	$("body").attr("data-layer-count", mandala.getLayerCount());

	render();
}

// --------------------------------------------------------------------
function setLayerProperty(property_key, layers, value )
{
	console.log(main_log_channel, `setLayerProp(${layers[0]}, ${property_key}, ${value})`);

	// model
	mandala.getLayer(layers[0])[property_key] = value;

	render();
};

// --------------------------------------------------------------------
function handleAction_setEditingLayers(action)
{
	console.log(main_log_channel, `setEditingLayers()`);
	console.log(main_log_channel, action.layers);

	syncLayerEditInputs();
}

// --------------------------------------------------------------------
function handleAction_highlightLayer(action)
{
	console.log(main_log_channel, `highlightLayer(${action.layers[0]})`);

	if (action.layers.length == 0)
	{
		$("g").attr("opacity", 1);
	}
	else
	{
		$("g[data-layer-name]").attr("opacity", 0.25);
		$(`g[data-layer-name=${action.layers[0]}]`).attr("opacity", 1);
	}
}

// --------------------------------------------------------------------
function handleAction_save(action)
{
	console.log(main_log_channel, `save()`);

	var mandala_json = mandala.toJSON();
	localStorage.setItem(storage_key_mandala, mandala_json);
}

// --------------------------------------------------------------------
function handleAction_restore(action)
{	
	console.log(main_log_channel, `restore()`);

	var mandala_json = localStorage.getItem(storage_key_mandala);

	if (null === mandala_json)
	{
		console.log(action_log_channel, `ERROR: no mandala object in localStorage`);
	}
	else
	{
		var mandala_obj = JSON.parse(mandala_json);
		mandala.fromJSON(mandala_obj);
		if (mandala.getLayerCount() > 0 )
		{
			layer_menu.sync();
			var layer = mandala.getLayerByIndex(0);
			layer_menu.setEditingLayer(layer.name);
		}
		$("body").attr("data-layer-count", mandala.getLayerCount());

		render();
	}
}

// --------------------------------------------------------------------
function handleAction_render(action)
{
	console.log(main_log_channel, "render()");
	render();
}

// --------------------------------------------------------------------
function handleAction_download(action)
{
	if (svg_blob_url)
	{
		window.URL.revokeObjectURL(svg_blob_url);
	}
	svg_blob_url = show_svg();

	save_dialog.start(svg_blob_url);
}

// --------------------------------------------------------------------
function queue_processing_done_callback()
{
	// console.log(main_log_channel, "queue_processing_done_callback()");

	if (mandala_integrity_check_after_queue_processing)
	{
		mandala.testIntegrity();
	}
}

// --------------------------------------------------------------------
var action_map = {};

action_map[Actions.ActionType.add_layer]					= handleAction_addLayer;
action_map[Actions.ActionType.set_layer_property]		= (action) => { setLayerProperty(action.layer_property, action.layers, action.value); }
action_map[Actions.ActionType.set_editing_layers]		= handleAction_setEditingLayers;
action_map[Actions.ActionType.delete_layer]				= handleAction_deleteLayer;
action_map[Actions.ActionType.highlight_layer]			= handleAction_highlightLayer;
action_map[Actions.ActionType.save]							= handleAction_save;
action_map[Actions.ActionType.restore]						= handleAction_restore;
action_map[Actions.ActionType.new_document]				= handleAction_newDocument;
action_map[Actions.ActionType.render]						= handleAction_render;
action_map[Actions.ActionType.clone_layer]				= handleAction_cloneLayer;
action_map[Actions.ActionType.download]					= handleAction_download;

Actions.setConfig({action_map:action_map, queue_processing_done_callback:queue_processing_done_callback});

// --------------------------------------------------------------------
// --------------------------------------------------------------------
// --------------------------------------------------------------------
$(document).ready( function()
{
	// ---- DATA INIT ----
	petal_class = initMandalaPetal();
	mandala_layer_class = MandalaLayerInit(petal_class);
	mandala = new Mandala(mandala_layer_class);
	mandala_svg_renderer = new MandalaSVGRenderer.MandalaSVGRenderer(mandala, {width:view_width, height:view_width});

	 // --- DUCTWORK ---
	 // TODO: move editor elements to their own class/component
    // num circles
    let numSpokesRangeCallback = myRangeInput.createRange({id:'numSpokesId',
        containerId:'numSpokesRangeContainer',
        onInputHandler:(value) => { 
			  Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	  [layer_menu.editing_layer],
																	  {value:value, layer_property:"number_of_spokes"}));
			}, 
		  initialValue:0, //default_number_of_spokes,
		  wheelStep:1,
        min:1, max:100, step:1})

	// num points
	let numPointsRangeCallback = myRangeInput.createRange({id:'numPointsId',
			containerId:'numPointsRangeContainer',
			onInputHandler:(value) => {
				Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	  [layer_menu.editing_layer],
																	  {value:value, layer_property:"number_of_points"}));
			},
			initialValue:1,
			wheelStep:1,
			min:1, max:25, step:1});

	// spoke end rotation
	let spokeEndRotRangeCallback = myRangeInput.createRange({id:'spokeEndRotId',
			containerId:'spokeEndRotRangeContainer',
			onInputHandler:(value) => {
				Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	  [layer_menu.editing_layer],
																	  {value:value, layer_property:"spoke_end_rot"}));
			},
			initialValue:0,
			wheelStep:Math.PI / 180, // 1 degree
			min:-Math.PI, max:Math.PI, step:0.01});  

	 // spoke length
    let spokeLengthRangeCallback = myRangeInput.createRange({id:'spokeLengthId',
        containerId:'spokeLengthRangeContainer',
        onInputHandler:(value) => {
			Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	[layer_menu.editing_layer],
																	{value:value, layer_property:"spoke_length"}));
		  },
		  initialValue:0, //default_spoke_length,
		  wheelStep:1,
        min:0, max:500, step:1})

    // spoke_rot_offset
    let spokeRotOffsetRangeCallback = myRangeInput.createRange({id:'spokeRotOffsetId',
        containerId:'spokeRotOffsetRangeContainer', 
        onInputHandler:(value) => {
			Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	[layer_menu.editing_layer], 
																	{value:value, layer_property:"spoke_rot_offset"}));
		  },
		  initialValue:0, //default_spoke_rot_offset,
		  wheelStep:Math.PI / 180,	// 1 degree
        min:0, max:Math.PI * 2, step:0.01})

    // radius
    let circleRadiusRangeCallback = myRangeInput.createRange({id:'circleRadiusId',
        containerId:'circleRadiusRangeContainer',
        onInputHandler:(value) => {
			Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	[layer_menu.editing_layer], 
																	{value:value, layer_property:"radius"}));
		  },
        initialValue:0, //default_circle_radius,
		  wheelStep:1,
        min:5, max:500, step:1})

    // stroke_width
    let strokeWidthRangeCallback = myRangeInput.createRange({id:'strokeWidthId',
        containerId:'strokeWidthRangeContainer',
        onInputHandler:(value) => {
			Actions.queueAction(new Actions.Action(	Actions.ActionType.set_layer_property,
																	[layer_menu.editing_layer],
																	{value:value, layer_property:"stroke_width"}));
		  },
		  initialValue:0, //default_stroke_width,
		  wheelStep:1,
        min:1, max:20, step:1})
	 
	// --- UI INIT ---
	color_picker = new fncColorPicker.Create({color_picked_handler:onColorPicked, size:250, container_div_id:"colorpick", hue:current_stroke_color.hue, rot_offset:-Math.PI * 0.5});
	color_picker_dialog = new modalize.Create($("body"), color_picker.$container_div, "colorpick_cover", {left:50,top:20});
	save_dialog = new SaveDialog.Create();

	// --- UI INIT ---
	layer_menu = new LayerMenu(mandala, Actions);
	layer_menu.generateMenu();
	$("body").append(layer_menu.$menu_content);

	// note that model initialization should sync controls to whatever goes into model

	// var new_layer = handleAction_addLayer({});
	// restore?
	var mandala_json = localStorage.getItem(storage_key_mandala);
	if (null !== mandala_json)
	{
		Actions.queueAction(new Actions.Action(Actions.ActionType.restore, []));
	}
	else
	{
		$("#restoreButtonId").prop("disabled", true);
		Actions.queueAction(new Actions.Action(Actions.ActionType.add_layer, []));
	}
	
	// petal = new petalClass({amplitude:20, number_of_points:20});

	render();
});

// --------------------------------------------------------------------
function onBodyLoad()
{
    view_width = window.innerWidth;
    view_height = window.innerHeight;
};

/*
// --------------------------------------------------------------------
function onWheel()
{
};

// --------------------------------------------------------------------
function logStats()
{
   //  console.log( "viewbox width: " + $("#mySVG")[0].viewBox.baseVal.width );
   //  console.log( "viewbox height: " + $("#mySVG")[0].viewBox.baseVal.height );
}

// --------------------------------------------------------------------
function zoomIn()
{
    $("#mySVG")[0].viewBox.baseVal.width -= 10;
    $("#mySVG")[0].viewBox.baseVal.height -= 10;

    logStats();
}

// --------------------------------------------------------------------
function zoomOut()
{
    $("#mySVG")[0].viewBox.baseVal.width += 10;
    $("#mySVG")[0].viewBox.baseVal.height += 10;

    logStats();
}
*/

// --------------------------------------------------------------------
function show_svg() {
    var svg = document.getElementById("mySVG");
    var serializer = new XMLSerializer();
    var svg_blob = new Blob([serializer.serializeToString(svg)],
                            {'type': "image/svg+xml"});
    var object_url = URL.createObjectURL(svg_blob);

    // later... revokeObjectURL();
	 // var svg_win = window.open(url, "svg_win");
	 return object_url;
}

// --------------------------------------------------------------------
function render()
{
    $("#mySVG").remove();

   // var svg_elem = generate_svg();
	var svg_elem = mandala_svg_renderer.renderWithPetals();

    $("body").append(svg_elem);
}


// TODO: move upward
var svg_blob_url = null;

var svg_file_version = 1;

// ----------------------------------------------------------------------------
// save state in local storage
function onSave()
{
	console.log(main_log_channel, "onSave()");
	Actions.queueAction(new Actions.Action(Actions.ActionType.save, []));
}

// ----------------------------------------------------------------------------
function onRestore()
{
	console.log(main_log_channel, "onRestore()");
	Actions.queueAction(new Actions.Action(Actions.ActionType.restore, []));
}

// ----------------------------------------------------------------------------
function onDownload()
{
	// TODO: move to function?
	if (svg_blob_url)
	{
		window.URL.revokeObjectURL(svg_blob_url);
	}
	svg_blob_url = show_svg();

	save_dialog.start(svg_blob_url);
}

// ----------------------------------------------------------------------------
function onAddLayer()
{
	var new_layer = addLayer();
	setCurrentLayer(new_layer.name);
	syncLayerEditInputs();
	render();
}

// ----------------------------------------------------------------------------
function onPickColor(is_picking_stroke_color)
{
	picking_stroke_color = is_picking_stroke_color;

	color_picker_dialog.start();
}

// ----------------------------------------------------------------------------
// callback from picker dialog
function onColorPicked(color)
{
	console.log(edit_log_channel, `onColorPicked:${JSON.stringify(color)}`)
	color_picker_dialog.dismiss();

	// picking fill or stroke?
	// oh man, gross
	if (picking_stroke_color)
	{
		current_stroke_color.set(color);
	}
	else
	{
		current_fill_color.set(color);
	}

	render();
}

// ----------------------------------------------------------------------------
function onStrokeEnabledChange()
{
	current_stroke_enabled.set($("#strokeEnabledChkId").prop("checked"));
}

// ----------------------------------------------------------------------------
function onFillEnabledChange()
{
	current_fill_enabled.set($("#fillEnabledChkId").prop("checked"));
}

// ----------------------------------------------------------------------------
var amplitude = 1;
var num_points = 100;
function sineTest()
{
	var max_x = view_width * 0.75;

	$("#mySVG").remove();

	var width = view_width;
	var height = view_height;
	var x = -width / 2;
	var y = -height / 2;

	x= 0; 

var svg_elem = `<svg width="100%" height="100%" id="mySVG" viewbox="${x} ${y} ${width} ${height}">`;

	var lines = "";
	lines += svgee.line(0,-100, 0, 100, {stroke:"rgb(200,200,200)", stroke_width:1});
	lines += svgee.line(0,0, max_x, 0, {stroke:"rgb(200,200,200)", stroke_width:1});

	svg_elem += lines;

	last_x = 0; last_y = 0;

	var total_distance = 0.0;

	var frequency = 1 / num_points;
	for (var index = 1; index <= num_points; index += 1)
	{
		var cur_t = index * frequency;
		var cur_y = Math.sin(Math.PI*2 * cur_t) * amplitude;
		var cur_x = cur_t * max_x;

		var cur_line = svgee.line(last_x, last_y, cur_x, cur_y, {stroke:"black"});
		svg_elem += cur_line;

		// dist
		var delta_x = cur_x - last_x;
		var delta_y = cur_y - last_y;
		total_distance += Math.sqrt( (delta_x*delta_x) + (delta_y*delta_y) );

		last_x = cur_x;
		last_y = cur_y;
		
	}

	svg_elem += lines;

	last_x = 0; last_y = 0;

	for (var index = 1; index <= num_points; index += 1)
	{
		var cur_t = index * frequency;
		var cur_y = Math.sin(Math.PI*2 * cur_t) * amplitude;
		var cur_x = cur_t * max_x;

		var cur_line = svgee.line(last_x, last_y, cur_x, cur_y, {stroke:"black"});
		svg_elem += cur_line;

		// dist
		var delta_x = cur_x - last_x;
		var delta_y = cur_y - last_y;
		total_distance += Math.sqrt( (delta_x*delta_x) + (delta_y*delta_y) );

		last_x = cur_x;
		last_y = cur_y;
		
	}



	svg_elem += "</svg>";

	$("body").append(svg_elem);

	console.log(`total distance = ${total_distance} `);
}

</script>

</head>

<!-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --  -->
<body data-layer-count="0" onload="onBodyLoad()">

<div class="menuBarClass" id="menuBarId">
	<table>
		<tr><td>petals</td><td id="numSpokesRangeContainer"></td></tr>
		<tr><td>num</td><td id="numPointsRangeContainer"></td></tr>
		<tr><td>end rot</td><td id="spokeEndRotRangeContainer"></td></tr>
		<tr><td>length</td><td id="spokeLengthRangeContainer"></td></tr>
		<tr><td>rot</td><td id="spokeRotOffsetRangeContainer"></td></tr>
		<tr><td>radius</td><td id="circleRadiusRangeContainer"></td></tr>
		<tr><td>stroke</td><td id="strokeWidthRangeContainer"></td></tr>
	</table>
	 <input type="checkbox" id="strokeEnabledChkId" onChange="onStrokeEnabledChange();">
	 <button id="strokeColorPickButtonId" class="pickColorButton" onclick="onPickColor(true)">sss</button>
	 <input type="checkbox" id="fillEnabledChkId" onChange="onFillEnabledChange();">
	 <button id="fillColorPickButtonId" class="pickColorButton" onclick="onPickColor(false)">fff</button>
</div>

<!-- <svg width="100%" height="100%" id="mySVG" viewbox="0 0 110 110"> -->
<!-- <g> -->
<!-- crosshairs -->
<!--
<line x1="-100" y1="0" x2="100" y2="0" style="stroke:rgb(0,0,0);stroke-width:2" />
<line x1="-0" y1="-100" x2="0" y2="100" style="stroke:rgb(0,0,0);stroke-width:2" />
-->
<!-- </g> -->
<!-- </svg> -->

</body>

</html>